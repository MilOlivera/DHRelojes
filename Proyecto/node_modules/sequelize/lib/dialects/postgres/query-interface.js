<<<<<<< HEAD
'use strict';

const DataTypes = require('../../data-types');
const Promise = require('../../promise');
const QueryTypes = require('../../query-types');
const _ = require('lodash');


/**
 Returns an object that handles Postgres special needs to do certain queries.

 @class QueryInterface
 @static
 @private
 */

/**
   * Ensure enum and their values.
   *
   * @param {QueryInterface} qi
   * @param {string} tableName  Name of table to create
   * @param {Object} attributes Object representing a list of normalized table attributes
   * @param {Object} [options]
   * @param {Model}  [model]
   *
   * @returns {Promise}
   * @private
   */
function ensureEnums(qi, tableName, attributes, options, model) {
  const keys = Object.keys(attributes);
  const keyLen = keys.length;

  let sql = '';
  let promises = [];
  let i = 0;

  for (i = 0; i < keyLen; i++) {
    const attribute = attributes[keys[i]];
    const type = attribute.type;

    if (
      type instanceof DataTypes.ENUM ||
      type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM
    ) {
      sql = qi.QueryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);
      promises.push(qi.sequelize.query(
        sql,
        Object.assign({}, options, { plain: true, raw: true, type: QueryTypes.SELECT })
      ));
    }
  }

  return Promise.all(promises).then(results => {
    promises = [];
    let enumIdx = 0;

    // This little function allows us to re-use the same code that prepends or appends new value to enum array
    const addEnumValue = (field, value, relativeValue, position = 'before', spliceStart = promises.length) => {
      const valueOptions = _.clone(options);
      valueOptions.before = null;
      valueOptions.after = null;

      switch (position) {
        case 'after':
          valueOptions.after = relativeValue;
          break;
        case 'before':
=======
"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const DataTypes = require("../../data-types");
const QueryTypes = require("../../query-types");
const { QueryInterface } = require("../abstract/query-interface");
const Utils = require("../../utils");
const Deferrable = require("../../deferrable");
class PostgresQueryInterface extends QueryInterface {
  async ensureEnums(tableName, attributes, options, model) {
    const keys = Object.keys(attributes);
    const keyLen = keys.length;
    let sql = "";
    let promises = [];
    let i = 0;
    for (i = 0; i < keyLen; i++) {
      const attribute = attributes[keys[i]];
      const type = attribute.type;
      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM) {
        sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);
        promises.push(this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { plain: true, raw: true, type: QueryTypes.SELECT })));
      }
    }
    const results = await Promise.all(promises);
    promises = [];
    let enumIdx = 0;
    const addEnumValue = (field, value, relativeValue, position = "before", spliceStart = promises.length) => {
      const valueOptions = __spreadValues({}, options);
      valueOptions.before = null;
      valueOptions.after = null;
      switch (position) {
        case "after":
          valueOptions.after = relativeValue;
          break;
        case "before":
>>>>>>> e63ce884e0231dbc908a29214b51bd3cf50ef810
        default:
          valueOptions.before = relativeValue;
          break;
      }
<<<<<<< HEAD

      promises.splice(spliceStart, 0, () => {
        return qi.sequelize.query(qi.QueryGenerator.pgEnumAdd(
          tableName, field, value, valueOptions
        ), valueOptions);
      });
    };

=======
      promises.splice(spliceStart, 0, () => {
        return this.sequelize.query(this.queryGenerator.pgEnumAdd(tableName, field, value, valueOptions), valueOptions);
      });
    };
>>>>>>> e63ce884e0231dbc908a29214b51bd3cf50ef810
    for (i = 0; i < keyLen; i++) {
      const attribute = attributes[keys[i]];
      const type = attribute.type;
      const enumType = type.type || type;
      const field = attribute.field || keys[i];
<<<<<<< HEAD

      if (
        type instanceof DataTypes.ENUM ||
        type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM
      ) {
        // If the enum type doesn't exist then create it
        if (!results[enumIdx]) {
          promises.push(() => {
            return qi.sequelize.query(qi.QueryGenerator.pgEnum(tableName, field, enumType, options), Object.assign({}, options, { raw: true }));
          });
        } else if (!!results[enumIdx] && !!model) {
          const enumVals = qi.QueryGenerator.fromArray(results[enumIdx].enum_value);
          const vals = enumType.values;

          // Going through already existing values allows us to make queries that depend on those values
          // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values
          // Then we append the rest of new values AFTER the latest already existing value
          // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]
          // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]
          // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]
=======
      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM) {
        if (!results[enumIdx]) {
          promises.push(() => {
            return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), __spreadProps(__spreadValues({}, options), { raw: true }));
          });
        } else if (!!results[enumIdx] && !!model) {
          const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);
          const vals = enumType.values;
>>>>>>> e63ce884e0231dbc908a29214b51bd3cf50ef810
          let lastOldEnumValue;
          let rightestPosition = -1;
          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {
            const enumVal = enumVals[oldIndex];
            const newIdx = vals.indexOf(enumVal);
            lastOldEnumValue = enumVal;
<<<<<<< HEAD

            if (newIdx === -1) {
              continue;
            }

            const newValuesBefore = vals.slice(0, newIdx);
            const promisesLength = promises.length;
            // we go in reverse order so we could stop when we meet old value
=======
            if (newIdx === -1) {
              continue;
            }
            const newValuesBefore = vals.slice(0, newIdx);
            const promisesLength = promises.length;
>>>>>>> e63ce884e0231dbc908a29214b51bd3cf50ef810
            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {
              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {
                break;
              }
<<<<<<< HEAD

              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);
            }

            // we detect the most 'right' position of old value in new enum array so we can append new values to it
=======
              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, "before", promisesLength);
            }
>>>>>>> e63ce884e0231dbc908a29214b51bd3cf50ef810
            if (newIdx > rightestPosition) {
              rightestPosition = newIdx;
            }
          }
<<<<<<< HEAD

          if (lastOldEnumValue && rightestPosition < vals.length - 1) {
            const remainingEnumValues = vals.slice(rightestPosition + 1);
            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {
              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');
            }
          }

=======
          if (lastOldEnumValue && rightestPosition < vals.length - 1) {
            const remainingEnumValues = vals.slice(rightestPosition + 1);
            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {
              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, "after");
            }
          }
>>>>>>> e63ce884e0231dbc908a29214b51bd3cf50ef810
          enumIdx++;
        }
      }
    }
<<<<<<< HEAD

    return promises
      .reduce((promise, asyncFunction) => promise.then(asyncFunction), Promise.resolve())
      .tap(() => {
        // If ENUM processed, then refresh OIDs
        if (promises.length) {
          return qi.sequelize.dialect.connectionManager._refreshDynamicOIDs();
        }
      });
  });
}


exports.ensureEnums = ensureEnums;
=======
    const result = await promises.reduce(async (promise, asyncFunction) => await asyncFunction(await promise), Promise.resolve());
    if (promises.length) {
      await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();
    }
    return result;
  }
  async getForeignKeyReferencesForTable(table, options) {
    const queryOptions = __spreadProps(__spreadValues({}, options), {
      type: QueryTypes.FOREIGNKEYS
    });
    const query = this.queryGenerator.getForeignKeyReferencesQuery(table.tableName || table, this.sequelize.config.database);
    const result = await this.sequelize.query(query, queryOptions);
    return result.map((fkMeta) => {
      const _a = Utils.camelizeObjectKeys(fkMeta), { initiallyDeferred, isDeferrable } = _a, remaining = __objRest(_a, ["initiallyDeferred", "isDeferrable"]);
      return __spreadProps(__spreadValues({}, remaining), {
        deferrable: isDeferrable === "NO" ? Deferrable.NOT : initiallyDeferred === "NO" ? Deferrable.INITIALLY_IMMEDIATE : Deferrable.INITIALLY_DEFERRED
      });
    });
  }
  async dropEnum(enumName, options) {
    options = options || {};
    return this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)), __spreadProps(__spreadValues({}, options), { raw: true }));
  }
  async dropAllEnums(options) {
    options = options || {};
    const enums = await this.pgListEnums(null, options);
    return await Promise.all(enums.map((result) => this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)), __spreadProps(__spreadValues({}, options), { raw: true }))));
  }
  async pgListEnums(tableName, options) {
    options = options || {};
    const sql = this.queryGenerator.pgListEnums(tableName);
    return this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { plain: false, raw: true, type: QueryTypes.SELECT }));
  }
  async dropTable(tableName, options) {
    await super.dropTable(tableName, options);
    const promises = [];
    const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: "tableName" });
    if (!instanceTable) {
      return;
    }
    const getTableName = (!options || !options.schema || options.schema === "public" ? "" : `${options.schema}_`) + tableName;
    const keys = Object.keys(instanceTable.rawAttributes);
    const keyLen = keys.length;
    for (let i = 0; i < keyLen; i++) {
      if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {
        const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);
        options.supportsSearchPath = false;
        promises.push(this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { raw: true })));
      }
    }
    await Promise.all(promises);
  }
}
exports.PostgresQueryInterface = PostgresQueryInterface;
//# sourceMappingURL=query-interface.js.map
>>>>>>> e63ce884e0231dbc908a29214b51bd3cf50ef810
